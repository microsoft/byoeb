import os
import datetime
import pymongo
import certifi
import json
from azure.monitor.opentelemetry import configure_azure_monitor
from azure.monitor.events.extension import track_event

class AppLogger:
    def __init__(self):
        
        self.blaclist_events = ['send_reaction', 'Scheduler']

        configure_azure_monitor(
            logger_name=os.environ["APPINSIGHT_LOGGER"],
            connection_string=os.environ["APPINSIGHT_CONNECTION_STRING"]
        )

        # trace.set_tracer_provider(TracerProvider())
        # self.tracer = trace.get_tracer(__name__)

    def add_event(self,
        event_name,
        event_properties):
        if event_name in self.blacklist_events:
            return
        track_event(event_name, event_properties)
        return

    def add_log(self,
        event_name,
        **kwargs):
        kwargs['details'] = json.dumps(kwargs['details'])
        #remove if anything is None
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        track_event(event_name, kwargs)
        return


class LoggingDatabase:
    def __init__(self, config) -> None:
        self.client = pymongo.MongoClient(os.environ["COSMOS_DB_CONNECTION_STRING"], tlsCAFile=certifi.where())
        self.db = self.client[config["COSMOS_DB_NAME"]]
        self.collection = self.db[config["COSMOS_LOGGING_COLLECTION"]]
        self.app_logger = AppLogger()

    def add_log(
        self,
        sender_id: str,
        receiver_id: str,
        message_id: str,
        action_type: str,
        details: str,
        timestamp: datetime.datetime,
    ) -> pymongo.results.InsertOneResult:
        """Creates a row in the collection.

        Args:
        """
        action_types = ['poll_response', 'send_message_template', 'Updating KnowledgeBase', 'send_correction', 'doctor reminder response']
        if action_type not in action_types:
            self.app_logger.add_log(action_type, details=details, sender_id=sender_id, receiver_id=receiver_id, message_id=message_id)
            return
        one_row = {
            "sender_id": sender_id,
            "receiver_id": receiver_id,
            "message_id": message_id,
            "action_type": action_type,
            "details": details,
            "timestamp": timestamp,
        }
        return self.collection.insert_one(one_row)

    def get_log_from_message_id(self, message_id):
        return list(self.collection.find({"message_id": message_id}))


class LongTermDatabase:
    def __init__(self, config) -> None:
        self.client = pymongo.MongoClient(os.environ["COSMOS_DB_CONNECTION_STRING"], tlsCAFile=certifi.where())
        self.db = self.client[config["COSMOS_DB_NAME"]]
        self.collection = self.db[config["COSMOS_LONGTERM_COLLECTION"]]
        print(f"Items in LongTerm DB: {self.collection.count_documents({})}")

    def get_rows(
        self,
        person_id: str,
        person_column: str,
    ) -> list[dict]:
        """
        Returns all the rows with the given person ID.
        filters using key: value as person_id: person_column

        """
        return list(self.collection.find({person_column: person_id}))

    def get_list_of(
        self,
        column: str,
    ) -> list[dict]:
        cursor = self.collection.find()
        list_cur = list(cursor)

        list_docs = []

        for doc in list_cur:
            if column in doc:
                list_docs.append(doc[column])

        return list_docs
    
    def get_list_of_multiple_columns(
        self,
        columns: list[str],
    ) -> list[dict]:
        cursor = self.collection.find()
        list_cur = list(cursor)

        list_docs = {
            column: [] for column in columns
        }

        for doc in list_cur:
            for column in columns:
                if column in doc:
                    list_docs[column].append(doc[column])
                else:
                    list_docs[column].append(None)
        
        return list_docs
    
    def add_language(
        self,
        _id: str,
        language: str,
        language_column: str,
    ) -> None:
        """Adds response to the row with the given ID.

        Args:
            _id (str): the ID of the row
            response (str): the response to be added
            response_message_id (str): the ID of the response (eg. telegram message ID)
        """
        self.collection.update_one(
            {"_id": _id},
            {
                "$set": {
                    language_column: language,
                }
            },
        )


class ConversationDatabase:
    def __init__(self, config) -> None:
        """initialize the database to store conversations

        Values stored in the database:

            - _id (str): the ID of the row (unique MongoDB ID; autogenerated)
            - user_id (str): user_id (eg. a unique telegram ID)
            - chat_id (str): the ID of the chat / group
            - query (str): the user query
            - query_message_id (str): ID of the query (eg. telegram message ID)
            - response (str): the response from the bot
            - response_id (str): ID of the response (eg. telegram message ID)
            - citations (str): the citations for the response
            - is_correct (bool): whether the response is correct or not
            - correction (str): the correction suggested by the doctor
            - correction_id (str): ID of the correction (eg. telegram message ID)
            - updated_response (str): the updated response created by the bot
            - updated_response_id (str): ID of the updated response (eg. telegram message ID)
            - timestamp (datetime.datetime): timestamp of the query
            - timestamp_response (datetime.datetime): timestamp of the bot's response
            - timestamp_correction (datetime.datetime): timestamp of the correction from the doctor
            - timestamp_updated_response (datetime.datetime): timestamp of the updated response from the bot
            - correction_qs_message_id (str): ID of the correction question
            - azure_blob_name (str): name of the blob
            - source_lang (str): source language concerned

        Args:
            config (dict[str, Any]): the main config (check main file)
        """

        self.client = pymongo.MongoClient(os.environ["COSMOS_DB_CONNECTION_STRING"], tlsCAFile=certifi.where())
        self.db = self.client[config["COSMOS_DB_NAME"]]
        self.collection = self.db[config["COSMOS_DB_COLLECTION"]]
        print(f"Items in Conversation DB: {self.collection.count_documents({})}")

    def insert_row(
        self,
        user_id: str,
        user_type: str,
        query: str,
        query_source_lang: str,
        source_lang: str,
        query_message_id: str,
        msg_type: str,
        timestamp: datetime.datetime,
    ) -> pymongo.results.InsertOneResult:
        """Creates a row in the collection.

        Args:
            collection (pymongo.collection.Collection): the mongodb collection
            query (str): the user query
            query_message_id (str): ID of the query (eg. telegram message ID)
        """
        one_row = {
            "user_id": user_id,
            "query": query,
            "query_source_lang": query_source_lang,
            "source_lang": source_lang,
            "query_type": None,
            "user_type": user_type,
            "query_message_id": query_message_id,
            "query_message_type": msg_type,
            "response": None,
            "response_message_id": None,
            "audio_response_message_id": None,
            "correction_qs_message_id": None,
            "citations": None,
            "is_correct": None,
            "is_forwarded": None,
            "forwarded_to": None,
            "correction": None,
            "correction_message_id": None,
            "updated_response": None,
            "updated_response_message_id": None,
            "timestamp": timestamp,
            "timestamp_response": None,
            "timestamp_correction": None,
            "timestamp_updated_response": None,
            "azure_blob_name": None,
            "source_lang": None,
            "poll_primary_id": None,
            "poll_escalated_id": None,
            "next_questions": None,
            "answered_by": None,
        }
        return self.collection.insert_one(one_row)

    def add_response(
        self,
        _id: str,
        response: str,
        response_source_lang: str,
        response_message_id: str,
        audio_response_message_id: str,
        query_type: str,
        timestamp_response: datetime.datetime,
    ) -> None:
        """Adds response to the row with the given ID.

        Args:
            _id (str): the ID of the row
            response (str): the response to be added
            response_message_id (str): the ID of the response (eg. telegram message ID)
        """
        self.collection.update_one(
            {"_id": _id},
            {
                "$set": {
                    "response": response,
                    "response_source_lang": response_source_lang,
                    "response_message_id": response_message_id,
                    "audio_response_message_id": audio_response_message_id,
                    "query_type": query_type,
                    "timestamp_response": timestamp_response,
                }
            },
        )

    def add_citations(
        self,
        _id: str,
        citations: str,
    ) -> None:
        """Adds citations to the row with the given ID.

        Args: add citations
            _id (str): the ID of the row
            citations (str): the citations to be added
        """
        self.collection.update_one(
            {"_id": _id},
            {
                "$set": {
                    "citations": citations,
                }
            },
        )

    def add_audio_name(
        self,
        _id: str,
        azure_blob_name: str,
    ) -> None:
        """Adds citations to the row with the given ID.

        Args:
            _id (str): the ID of the row
            citations (str): the citations to be added
        """
        self.collection.update_one(
            {"_id": _id},
            {
                "$set": {
                    "azure_blob_name": azure_blob_name,
                }
            },
        )

    def add_is_forwarded(
        self,
        _id: str,
        forwarded_to: str,
        forwarded_by: str,
    ) -> None:
        """adds is_forwarded to the row with the given ID

        Args:
            collection (pymongo.collection.Collection): the mongodb collection
            _id (str): id of the row
            sent_to (str): the ID of the person the query was forwarded to (Doctor/Counsellor)
            forwarded_by (str): the ID of the person who forwarded the query
        """
        self.collection.update_one(
            {"_id": _id},
            {
                "$set": {
                    "is_forwarded": True,
                    "forwarded_to": forwarded_to,
                }
            },
        )

    def add_is_correct(
        self,
        _id: str,
        is_correct: bool,
        answered_by: str,
    ) -> None:
        """adds is_correct to the row with the given ID

        Args:
            collection (pymongo.collection.Collection): the mongodb collection
            _id (str): id of the row
            is_correct (bool): did the expert think the response was correct
        """
        self.collection.update_one(
            {"_id": _id},
            {
                "$set": {
                    "is_correct": is_correct,
                    "answered_by": answered_by,
                }
            },
        )

    def add_correction(
        self,
        _id: str,
        correction: str,
        correction_message_id: str,
        timestamp_correction: datetime.datetime,
    ) -> None:
        """adds correction to the row with the given ID

        Args:
            collection (pymongo.collection.Collection): the mongodb collection
            _id (str): id of the row
            correction (str): the correction
            correction_message_id (str): the ID of the correction (eg. telegram message ID)
        """
        self.collection.update_one(
            {"_id": _id},
            {
                "$set": {
                    "correction": correction,
                    "correction_message_id": correction_message_id,
                    "timestamp_correction": timestamp_correction,
                }
            },
        )

    def add_updated_response(
        self,
        _id: str,
        updated_response: str,
        updated_response_source_lang: str,
        updated_response_message_id: str,
        timestamp_updated_response: datetime.datetime,
    ) -> None:
        """adds updated_response to the row with the given ID

        Args:
            collection (pymongo.collection.Collection): the mongodb collection
            _id (str): the ID of the row
            updated_response (str): the updated response after combining the correction, query and response
            updated_response_id (str): id of the updated response (eg. telegram message ID)
        """
        self.collection.update_one(
            {"_id": _id},
            {
                "$set": {
                    "updated_response": updated_response,
                    "updated_response_source_lang": updated_response_source_lang,
                    "updated_response_message_id": updated_response_message_id,
                    "timestamp_updated_response": timestamp_updated_response,
                }
            },
        )


    def get_collection_count(
        self,
    ) -> int:
        """get the number of rows in the collection

        Args:
            collection (pymongo.collection.Collection): the mongodb collection

        Returns:
            int: number of rows in the collection
        """
        return self.collection.count_documents({})

    def get_rows_with_user_id(
        self,
        user_id: str,
        user_type: str,
    ):
        """get the row with the given user ID

        Args:
            collection (pymongo.collection.Collection): the mongodb collection
            user_id (str): the ID of the user

        Returns:
            dict: the row with the given user ID
        """
        return list(
            self.collection.find(
                {"$and": [{"user_id": user_id}, {"user_type": user_type}]}
            )
        )

    def get_all_rows(
        self,
    ) -> list[dict]:
        """get all rows from the collection

        Args:
            collection (pymongo.collection.Collection): the mongodb collection

        Returns:
            list[dict]: all rows
        """
        return list(self.collection.find({}))

    def get_row_with_id(
        self,
        _id: str,
    ) -> dict:
        """get the row with the given ID

        Args:
            collection (pymongo.collection.Collection): the mongodb collection
            _id (str): id of the row

        Returns:
            dict: the row
        """
        return self.collection.find_one({"_id": _id})

    def get_rows(
        self,
        person_id: str,
        person_column: str,
    ) -> list[dict]:
        """
        Returns all the rows with the given person ID.
        filters using key: value as person_id: person_column

        """
        return list(self.collection.find({person_column: person_id}))


    def get_rows_by_msg_id(
        self,
        msg_id: str,
    ) -> list[dict]:
        """get all rows with the given chat_id

        Args:
            collection (pymongo.collection.Collection): the mongodb collection
            chat_id (str): the ID of the chat / group

        Returns:
            list[dict]: all rows with the given chat_id
        """
        return list(self.collection.find({"query_message_id": msg_id}))

    def get_rows_custom_filter(
        self,
        filter: dict,
    ) -> list[dict]:
        """get all rows with the given filter

        Args:
            collection (pymongo.collection.Collection): the mongodb collection
            filter (dict): the filter

        Returns:
            list[dict]: all rows with the given filter
        """
        return list(self.collection.find(filter))

    def delete_row(
        self,
        _id: str,
    ) -> None:
        """delete the row with the given ID

        Args:
            collection (pymongo.collection.Collection): the mongodb collection
            _id (str): id of the row
        """
        self.collection.delete_one({"_id": _id})

    def delete_all_rows(
        self,
    ) -> None:
        """delete all rows

        Args:
            collection (pymongo.collection.Collection): the mongodb collection
        """
        self.collection.delete_many({})

    def find_db_id_with_query_msg_id(
        self,
        query_msg_id: str,
    ):
        return list(self.collection.find({"query_message_id": query_msg_id}))

    def find_db_id_with_message_id(self, reply_id):
        return list(
            self.collection.find(
                {
                    "$or": [
                        {"poll_primary_id": reply_id},
                        {"poll_escalated_id": reply_id},
                    ]
                }
            )
        )

    def add_correction_qs_id(
        self,
        _id: str,
        correction_qs_message_id: str,
    ) -> None:
        self.collection.update_one(
            {"_id": _id},
            {
                "$set": {
                    "correction_qs_message_id": correction_qs_message_id,
                }
            },
        )

    def add_poll_primary_id(
        self,
        _id: str,
        poll_primary_id: str,
    ) -> None:
        self.collection.update_one(
            {"_id": _id},
            {
                "$set": {
                    "poll_primary_id": poll_primary_id,
                }
            },
        )

    def find_with_poll_primary_id(self, poll_primary_id):
        return list(self.collection.find({"poll_primary_id": poll_primary_id}))

    def add_poll_escalated_id(
        self,
        _id: str,
        poll_escalated_id: str,
    ) -> None:
        self.collection.update_one(
            {"_id": _id},
            {
                "$set": {
                    "poll_escalated_id": poll_escalated_id,
                }
            },
        )

    def find_with_poll_escalated_id(self, poll_escalated_id):
        return list(self.collection.find({"poll_escalated_id": poll_escalated_id}))

    def add_next_questions(
        self,
        _id: str,
        next_questions: str,
    ) -> None:
        self.collection.update_one(
            {"_id": _id},
            {
                "$set": {
                    "next_questions": next_questions,
                }
            },
        )

    def get_next_questions(self, user_id, user_type):
        prev_rows = list(
                self.collection.find(
                    {"$and": [{"user_id": user_id}, {"user_type": user_type}]}
        ))
        try:
            user_row = prev_rows[-2]
        except:
            user_row = prev_rows[-1]
        return user_row["next_questions"]

    def get_all_message_ids(self):
        cursor = self.collection.find()
        list_cur = list(cursor)

        list_docs = []

        for doc in list_cur:
            if "query_message_id" in doc:
                list_docs.append(doc["query_message_id"])

        return list_docs

    def get_rows_timestamp(self, ts_column, from_ts, to_ts):
        return list(self.collection.find({ts_column: {"$gte": from_ts, "$lte": to_ts}}))

    def add_query_type(
        self,
        _id: str,
        query_type: str,
    ) -> None:
        """adds is_correct to the row with the given ID

        Args:
            collection (pymongo.collection.Collection): the mongodb collection
            _id (str): id of the row
            is_correct (bool): did the expert think the response was correct
        """
        self.collection.update_one(
            {"_id": _id},
            {
                "$set": {
                    "query_type": query_type,
                }
            },
        )
